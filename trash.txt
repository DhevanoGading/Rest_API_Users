app.delete("/user/:id", validateToken("admin"), (req, res) => {
  const { id } = req.body;
  User.destroy({ where });
});

/**
 * @swagger
 * components:
 *    schemas:
 *      User:
 *        type: object
 *        properties:
 *          id:
 *            type: integer
 *          email:
 *            type: string
 *          password:
 *            type: string
 *          role:
 *            type: string
 *            enum:
 *              - admin
 *              - user
 */

// Atur header CORS di sisi server
// res.header("Access-Control-Allow-Origin", "http://localhost:4200");
// res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
// res.header(
//   "Access-Control-Allow-Headers",
//   "Origin, X-Requested-With, Content-Type, Accept"
// );
// res.header("Access-Control-Allow-Credentials", "true");

// const cookieOptions = {
//   maxAge: 24 * 60 * 60 * 1000,
//   // Set domain dan path sesuai kebutuhan Anda
//   domain: "localhost",
//   path: "/login",
//   // Izinkan kredensial di CORS
//   sameSite: "none",
//   secure: true,
// };
// res.setHeader(
//   "Set-Cookie",
//   serialize("access-token", accessToken, cookieOptions)
// );

const express = require("express");
const app = express();
const db = require("./models");
const { User } = require("./models");
const bcrypt = require("bcrypt");
const cors = require("cors");
require("dotenv").config();

const swaggerJSDoc = require("swagger-jsdoc");
const swaggerUi = require("swagger-ui-express");

const cookieParser = require("cookie-parser");
const { generateTokens, validateToken } = require("./jwt");

const PORT = process.env.APP_PORT || 3000;

app.use(
  "*",
  cors({
    origin: true,
    credentials: true,
  })
);

app.use(express.json());
app.use(cookieParser());
app.use(express.urlencoded({ extended: false }));

const option = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Node JS API User with MySQL",
      version: "1.0.0",
    },
    servers: [
      {
        url: `http://localhost:${PORT}`,
      },
    ],
  },
  apis: ["./index.js"],
};

const swaggerSpec = swaggerJSDoc(option);
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

/**
 * @swagger
 * components:
 *   schemas:
 *     Auth:
 *       type: object
 *       properties:
 *         email:
 *           type: string
 *         password:
 *           type: string
 *       required:
 *         - email
 *         - password
 *       additionalProperties: false
 */

/**
 * @swagger
 * /register/admin:
 *  post:
 *    summary: Register admin
 *    description: This api is used to admin register
 *    requestBody:
 *      required: true
 *      content:
 *        application/json:
 *          schema:
 *            $ref: '#components/schemas/Auth'
 *    responses:
 *      200:
 *        description: Register successfully
 */

//register admin
app.post("/register/admin", (req, res) => {
  const { email, password } = req.body;
  bcrypt.hash(password, 10).then((hash) => {
    User.create({
      email: email,
      password: hash,
      role: "admin",
    })
      .then((result) => {
        res.json({
          data: result,
          message: "User Registered!",
        });
      })
      .catch((err) => {
        if (err) {
          res.status(400).json({ error: err });
        }
      });
  });
});

/**
 * @swagger
 * /register:
 *  post:
 *    summary: Register user
 *    description: This api is used to user register
 *    requestBody:
 *      required: true
 *      content:
 *        application/json:
 *          schema:
 *            $ref: '#components/schemas/Auth'
 *    responses:
 *      200:
 *        description: Register successfully
 */

//register user
app.post("/register", (req, res) => {
  const { email, password } = req.body;
  bcrypt.hash(password, 10).then((hash) => {
    User.create({
      email: email,
      password: hash,
      role: "user",
    })
      .then((result) => {
        res.json({
          data: result,
          message: "User Registered!",
        });
      })
      .catch((err) => {
        if (err) {
          res.status(400).json({ error: err });
        }
      });
  });
});

/**
 * @swagger
 * /login:
 *   post:
 *     summary: Login user
 *     description: This API is used for user login
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Auth'
 *     responses:
 *       200:
 *         description: Login successfully
 */

//login
app.post("/login", async (req, res) => {
  const { email, password } = req.body;

  const user = await User.findOne({ where: { email: email } });

  if (!user) {
    res.status(400).json({ error: "User Doesn't Exist!" });
  } else {
    const dbPassword = user.password;
    bcrypt.compare(password, dbPassword).then((match) => {
      if (!match) {
        res.status(400).json({ error: "Invalid password!" });
      } else {
        const accessToken = generateTokens(user);
        res.cookie("access_token", accessToken, {
          maxAge: 24 * 60 * 60 * 1000,
          httpOnly: true,
        });
        res.json({
          message: "Logged in Succesfully!",
          user: {
            id: user.id,
            email: user.email,
            role: user.role,
          },
        });
      }
    });
  }
});

/**
 * @swagger
 * /logout:
 *  post:
 *    summary: Logout user
 *    description: This api is used to clear cookie
 *    responses:
 *      200:
 *        description: Logout Succesfully!
 */

//logout
app.post("/logout", validateToken(), (req, res) => {
  // Hapus cookie 'access-token'
  res.clearCookie("access_token");
  res.json({ message: "Logged out successfully" });
});

/**
 * @swagger
 * components:
 *    schemas:
 *      User:
 *        type: object
 *        properties:
 *          id:
 *            type: integer
 *          email:
 *            type: string
 *          password:
 *            type: string
 *          role:
 *            type: string
 *            enum:
 *              - admin
 *              - user
 */

/**
 * @swagger
 * /user:
 *  get:
 *    summary: Get all data users
 *    description: This api is used to get all data users
 *    responses:
 *      200:
 *        description: Success response
 *        content:
 *          application/json:
 *            schema:
 *              type: array
 *              items:
 *                $ref: '#components/schemas/User'
 */

//get all user
app.post("/user", validateToken("admin"), (req, res) => {
  const token = req.body.accessToken;
  User.findAll()
    .then((result) => {
      res.json(result);
    })
    .catch((err) => {
      console.log(err);
    });
});

/**
 * @swagger
 * /profile/{id}:
 *  get:
 *    summary: Get data users
 *    description: This api is used to get data user
 *    parameters:
 *      - in: path
 *        name: id
 *        required: true
 *        description: Numeric ID required
 *        schema:
 *          type: integer
 *    responses:
 *      200:
 *        description: Success response
 *        content:
 *          application/json:
 *            schema:
 *              type: array
 *              items:
 *                $ref: '#components/schemas/User'
 */

//get user
app.post("/profile/:id", validateToken(), (req, res) => {
  const { id } = req.params;
  const tokenUserId = req.user.id;
  // Memeriksa apakah ID pengguna dalam token sama dengan ID pengguna dalam URL
  if (parseInt(id) !== tokenUserId) {
    return res.status(403).json({ error: "Access denied!" });
  }
  User.findOne({ where: { id: id } })
    .then((result) => {
      if (result) {
        res.json(result);
      } else {
        res.status(404).json({ error: "User not found" });
      }
    })
    .catch((err) => {
      console.log(err);
    });
});

db.sequelize.sync().then((req) => {
  app.listen(PORT, () => {
    console.log(`Server listening at http://localhost:${PORT}`);
  });
});

const { sign, verify } = require("jsonwebtoken");
const KEY = "jwtuserlogin";

const generateTokens = (user) => {
  const accessToken = sign(
    {
      id: user.id,
      email: user.email,
      role: user.role,
    },
    KEY
  );
  return accessToken;
};

const validateToken = (requiredRole) => (req, res, next) => {
  // const accessToken = req.cookies["access_token"];
  const accessToken = req.body.accessToken;

  if (!accessToken || accessToken === undefined || accessToken === "")
    return res.status(400).json({ error: "User not Autenticated!" });

  try {
    const validToken = verify(accessToken, KEY);
    console.log(validToken);
    if (validToken) {
      req.authenticated = true;
      if (requiredRole && requiredRole !== validToken.role) {
        return res.status(400).json({ error: "Unauthorized access!" });
      }
      req.user = validToken;
      return next();
    }
  } catch (err) {
    res.status(400).json({ error: err });
  }
};

module.exports = { generateTokens, validateToken };

const dbPassword = user.password;
const match = await bcrypt.compare(password, dbPassword);

if (!match) {
  res.status(400).json({ error: "Invalid password!" });
} else {
  const accessToken = generateTokens(user);
  res.cookie("access_token", accessToken, {
    maxAge: 24 * 60 * 60 * 1000,
    httpOnly: true,
  });
  res.json({
    message: "Logged in Succesfully!",
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
    },
  });
}

await Karyawan.create(dataKaryawan)
  .then((result) => {
    res.json({
      result,
      message: "Add karyawan Successfully!",
    });
  })
  .catch((err) => {
    res.json({
      message: err.message,
    });
  });
const token = req.headers.cookie;
const tokenArr = token.split("=");
const accessToken = tokenArr[1];

paginatedResult: async (model) => {
  return (req, res, next) => {
    const page = parseInt(req.query.page);
    const limit = parseInt(req.query.limit);

    const startIndex = (page - 1) * limit;
    const endIndex = page * limit;

    const results = {};

    if (endIndex < model.length) {
      results.next = {
        page: page + 1,
        limit,
      };
    }

    if (startIndex > 0) {
      results.previous = {
        page: page - 1,
        limit,
      };
    }

    try {
      results.results = model.findAll().limit(limit).skip(startIndex).exec();
      res.paginatedResult = results;
    } catch (err) {
      res.json({ message: err.message });
    }
  };
};
async function getAll(req, res) {
  try {
    paginatedResult(User)(req, res, async () => {
      const { results, previous, next } = res.paginatedResult;

      const usersWithoutPassword = results.map((user) => {
        const { password, ...userData } = user.toJSON();
        return userData;
      });

      res.json({
        results: usersWithoutPassword,
        previous: previous,
        next: next,
      });
    });
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: err.message });
  }
}

const {
  karyawanId,
  namaLengkap,
  tempatLahir,
  tglLahir,
  email,
  telegramId,
  nomorTelepon,
  jenisIdentitas,
  nomorIdentitas,
  statusPernikahan,
  alamatKtp,
  pendidikanAkhir,
  namaInstitusi,
  jurusan,
  nikKaryawan,
  divisi,
  resource,
  posisi,
  statusKaryawan,
  penempatan,
  tglBergabung,
  userRole,
} = req.body;

/**
 *    parameters:
 *      - in: query
 *        name: page
 *        schema:
 *          type: integer
 *        description: The number of page
 *      - in: query
 *        name: limit
 *        schema:
 *          type: integer
 *        description: The limit of data
 */

try {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;

  const paginatedData = await paginatedResult(Karyawan, page, limit);

  const karyawansWithoutPassword = paginatedData.results.map((karyawan) => {
    const { password, ...karyawanData } = karyawan.toJSON();
    return karyawanData;
  });

  res.status(200).json({
    message: "get karyawan successfully!",
    data: {
      results: karyawansWithoutPassword,
      previous: paginatedData.previous,
      next: paginatedData.next,
    },
  });
} catch (error) {
  console.log(error);
  res.status(500).json({ message: error.message });
}

const karyawan = await Karyawan.findOne({
  attributes: [
    "karyawanId",
    "namaLengkap",
    "statusPernikahan",
    "nikKaryawan",
    "nomorIdentitas",
    "divisi",
    "tglBergabung",
    "statusKaryawan",
    "email",
    "nomorTelepon",
    "alamatKTP",
    "posisi",
    "resource",
    "penempatan",
    "telegramId",
    "createdBy",
    "createdDate",
    "pendidikanAkhir",
    "namaInstitusi",
    "tempatlahir",
    "tglLahir",
    "status",
    "roleTrello",
    "jurusan",
    [sequelize.col("Member.username"), "username"],
    "userRole",
  ],
  include: [
    {
      model: Member,
      attributes: ["username"],
    },
  ],
  where: { namaLengkap: namaLengkap },
});

// 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
// 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

"615e5696f4e07f3659e805db", "Dhevano", "dhevanogading";
"649a3c1d3cf496beaf467979", "Dhevano Gading", "muhammaddhevano";

// 'date_format(current_timestamp(),''%Y-%m-%d %H:%i:%s'')'


/**
 * @swagger
 * /user/find:
 *  post:
 *    tags: [User]
 *    summary: Search user
 *    description: This api is used to search user
 *    parameters:
 *      - in: body
 *        name: requestBody
 *        description: Keyword for searching
 *        required: false
 *        schema:
 *          type: object
 *          properties:
 *           keyword:
 *             type: string
 *    responses:
 *      200:
 *        description: user founded!
 */
router.post("/find", validateToken("admin"), userController.findUser);
